// GENERATED BY 'T'ransport 'G'enerator. DO NOT EDIT.
package transport

import (
	"strings"
	"sync"

	"github.com/gofiber/fiber/v2"
	"github.com/seniorGolang/json"
)

func (http *httpUser) serveGetUserNameByID(ctx *fiber.Ctx) (err error) {
	return http.serveMethod(ctx, "getusernamebyid", http.getUserNameByID)
}
func (http *httpUser) getUserNameByID(ctx *fiber.Ctx, requestBase baseJsonRPC) (responseBase *baseJsonRPC) {
	var err error
	var request requestUserGetUserNameByID
	if requestBase.Params != nil {
		if err = json.Unmarshal(requestBase.Params, &request); err != nil {
			return makeErrorResponseJsonRPC(requestBase.ID, parseError, "request body could not be decoded: "+err.Error(), nil)
		}
	}
	if requestBase.Version != Version {
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "incorrect protocol version: "+requestBase.Version, nil)
	}
	methodContext := ctx.Context()

	var response responseUserGetUserNameByID
	response.Name, err = http.svc.GetUserNameByID(methodContext, request.Id)
	if err != nil {
		if http.errorHandler != nil {
			err = http.errorHandler(err)
		}
		return makeErrorResponseJsonRPC(requestBase.ID, internalError, err.Error(), err)
	}
	responseBase = &baseJsonRPC{
		ID:      requestBase.ID,
		Version: Version,
	}
	if responseBase.Result, err = json.Marshal(response); err != nil {
		return makeErrorResponseJsonRPC(requestBase.ID, parseError, "response body could not be encoded: "+err.Error(), nil)
	}
	return
}
func (http *httpUser) serveBatch(ctx *fiber.Ctx) (err error) {
	methodHTTP := ctx.Method()
	if methodHTTP != fiber.MethodPost {
		ctx.Response().SetStatusCode(fiber.StatusMethodNotAllowed)
		if _, err = ctx.WriteString("only POST method supported"); err != nil {
			return
		}
		return
	}
	if value := ctx.Context().Value(CtxCancelRequest); value != nil {
		return
	}
	var single bool
	var requests []baseJsonRPC
	if err = json.Unmarshal(ctx.Body(), &requests); err != nil {
		var request baseJsonRPC
		if err = json.Unmarshal(ctx.Body(), &request); err != nil {
			return sendResponse(http.log, ctx, makeErrorResponseJsonRPC([]byte("\"0\""), parseError, "request body could not be decoded: "+err.Error(), nil))
		}
		single = true
		requests = append(requests, request)
	}
	responses := make(jsonrpcResponses, 0, len(requests))
	var wg sync.WaitGroup
	for _, request := range requests {
		methodNameOrigin := request.Method
		method := strings.ToLower(request.Method)
		switch method {
		case "getusernamebyid":
			wg.Add(1)
			func(request baseJsonRPC) {
				responses.append(http.getUserNameByID(ctx, request))
				wg.Done()
			}(request)
		default:
			responses.append(makeErrorResponseJsonRPC(request.ID, methodNotFoundError, "invalid method '"+methodNameOrigin+"'", nil))
		}
	}
	wg.Wait()
	if single {
		return sendResponse(http.log, ctx, responses[0])
	}
	return sendResponse(http.log, ctx, responses)
}
func (http *httpUser) serveMethod(ctx *fiber.Ctx, methodName string, methodHandler methodJsonRPC) (err error) {
	methodHTTP := ctx.Method()
	if methodHTTP != fiber.MethodPost {
		ctx.Response().SetStatusCode(fiber.StatusMethodNotAllowed)
		if _, err = ctx.WriteString("only POST method supported"); err != nil {
			return
		}
	}
	if value := ctx.Context().Value(CtxCancelRequest); value != nil {
		return
	}
	var request baseJsonRPC
	var response *baseJsonRPC
	if err = json.Unmarshal(ctx.Body(), &request); err != nil {
		return sendResponse(http.log, ctx, makeErrorResponseJsonRPC([]byte("\"0\""), parseError, "request body could not be decoded: "+err.Error(), nil))
	}
	methodNameOrigin := request.Method
	method := strings.ToLower(request.Method)
	if method != "" && method != methodName {
		return sendResponse(http.log, ctx, makeErrorResponseJsonRPC(request.ID, methodNotFoundError, "invalid method "+methodNameOrigin, nil))
	}
	response = methodHandler(ctx, request)
	if response != nil {
		return sendResponse(http.log, ctx, response)
	}
	return
}
